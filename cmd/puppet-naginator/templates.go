package main

import (
	"bytes"
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/nightlyone/puppetquery"
)

const nagiosPrefix = "Nagios_"
const naginatorName = "_naginator_name"

var nagiosTypes = []string{
	"command",
	"contact",
	"contactgroup",
	"host",
	"hostdependency",
	"hostescalation",
	"hostextinfo",
	"hostgroup",
	"service",
	"servicedependency",
	"serviceescalation",
	"serviceextinfo",
	"servicegroup",
	"timeperiod",
}

// naginators derives these from the resource title, if missing
var nameVars = map[string]string{
	"command":           "command_name",
	"contact":           "contact_name",
	"contactgroup":      "contactgroup_name",
	"host":              "host_name",
	"hostdependency":    naginatorName,
	"hostescalation":    naginatorName,
	"hostextinfo":       "host_name",
	"hostgroup":         "hostgroup_name",
	"service":           naginatorName,
	"servicedependency": naginatorName,
	"serviceescalation": naginatorName,
	"serviceextinfo":    naginatorName,
	"servicegroup":      "servicegroup_name",
	"timeperiod":        "timeperiod_name",
}

// https://docs.puppetlabs.com/references/latest/metaparameter.html
var metaparams = []string{
	// "alias", alias is needed in naginator although it is a metaparameter
	"audit",
	"before",
	"loglevel",
	"noop",
	"notify",
	"require",
	"schedule",
	"stage",
	"subscribe",
	"tag",
}

var keyOrder = slice2map(append(uniqValues(nameVars), "alias", "use", "parents", "service_description"))
var badparams = slice2map(append(metaparams, "target", "ensure", "provider", "_naginator_name"))

func uniqValues(in map[string]string) []string {
	out := make([]string, 0, len(in))
	seen := make(map[string]bool, len(in))
	for _, v := range in {
		if seen[v] {
			continue
		}
		seen[v] = true
		out = append(out, v)
	}
	return out
}

func slice2map(s []string) map[string]int {
	m := make(map[string]int, len(s))
	for i, v := range s {
		m[v] = i
	}
	return m
}

func removeEmptyStrings(in []string, size int) []string {
	out := make([]string, 0, size)
	for _, v := range in {
		if v != "" {
			out = append(out, v)
		}
	}
	return out
}

// order key in special nagios order
func orderedKeys(kv map[string]interface{}) []string {
	first_keys := make([]string, len(keyOrder))
	keys := make([]string, 0, len(kv))

	for key := range kv {
		if index, found := keyOrder[key]; found {
			first_keys[index] = key
		} else {
			keys = append(keys, key)
		}
	}
	sort.Strings(keys)
	return append(removeEmptyStrings(first_keys, len(kv)), keys...)
}

// removeDuplicateResources allows only one resource with the same title
func removeDuplicateResources(resources []puppetquery.Resource) []puppetquery.Resource {
	// no duplicates possible
	if len(resources) < 2 {
		return resources
	}

	seen := make(map[string]bool, len(resources))
	uniq := make([]puppetquery.Resource, 0, len(resources))

	seen[resources[0].Title] = true
	uniq = append(uniq, resources[0])
	for _, r := range resources[1:] {
		if seen[r.Title] {
			continue
		}
		seen[r.Title] = true
		uniq = append(uniq, r)
	}
	return uniq
}

func generate(b *bytes.Buffer, dt time.Time, resources []puppetquery.Resource) error {
	fmt.Fprintln(b, "# HEADER: This file was autogenerated at", dt.Format(time.RubyDate))
	b.WriteString("# HEADER: by puppet.  While it can still be managed manually, it\n")
	b.WriteString("# HEADER: is definitely not recommended.\n")

	for i, r := range removeDuplicateResources(resources) {
		if i != 0 {
			b.WriteByte('\n')
		}

		typ := strings.TrimPrefix(r.Type, nagiosPrefix)
		// derive some parameters from the title. Puppet calls this "namevar"
		if namevar := nameVars[typ]; r.Parameters[namevar] == nil {
			r.Parameters[namevar] = r.Title
		}

		fmt.Fprintln(b, "define", typ, "{")
		if nameVars[typ] == naginatorName {
			fmt.Fprintf(b, "\t## --PUPPET_NAME-- (called '_naginator_name' in the manifest)                %s\n", r.Parameters[naginatorName])
			delete(r.Parameters, naginatorName)
		}

		for _, k := range orderedKeys(r.Parameters) {
			if _, found := badparams[k]; found {
				continue
			}
			v := r.Parameters[k]
			// puppetdb stores "large" integers as float. So we simply format them as big integers,
			// since for nagios they are uint64
			switch v := v.(type) {
			case float32:
				fmt.Fprintf(b, "\t%-30s %.0f\n", k, v)
			case float64:
				fmt.Fprintf(b, "\t%-30s %.0f\n", k, v)
			default:
				fmt.Fprintf(b, "\t%-30s %v\n", k, v)
			}
		}
		b.WriteString("}\n")
	}

	return nil
}
